 # Crafting Requirement's Program
    #### Video Demo: https://youtu.be/fVwX904CagY?si=gpg7OUG_ZAZnoTS-

# Purpose of the program:
My program’s purpose is to return the crafting requirements for a number of a particular item in a game. The item in question is specified as an argument, and the amount of that item you want to craft can be taken as a second argument, or can be left blank wherein thereafter running the code with one argument, an input is brought up to get the amount. When run through the **craft_req** function, it returns the crafting requirements for said item taken into account the amount of said item, along with an image of the item.

## Accounting for arguments
My program requires the user to give an item through either an input or a string inside the **craft_req** function. The first argument is expected to be some sort of string, so if someone decides to put in an integer as the first argument an *AttributeError* with the following message *(“The first input has to be a string)* will be raised. The function call requires at least one argument, with an optional second argument  which acts as the amount of the item you would want to create. If you do not assign two arguments to the **craft_req** function and only assign one, the program will ask you to input a value for the missing second argument which is the amount of the item you want to create. In addition if the second argument cannot be turned into an integer the following will be raised: *ValueError (“Put in a number for the second input”)*



# Detailed Summary of each step of the program

## First function (check_dictionary)
Going through the program top-down, the first function the program goes through is **check_dictionary**, wherein it takes one string argument as a parameter, and assign it the *.strip* and *.lower* properties to make it effectively check whether that argument the user gives is inside a dictionary regardless of capitalization or white space, wherein the keys of the dictionary are an item’s name and the values are that item’s respective image. This is also where the Attribute error check is located to make sure the first argument is at least a string, and then after it checks if the item is inside the dictionary, if it is **check_dictionary** returns the item image, if it isn’t it raises: *IndexError (“No object by that name”)*


## Next function (amount)
Next is the amount function which takes in two arguments. It accesses the return value of the **check_dictionary** function as an “item” variable, and if only one argument was were given through the call of the **craft_req**  function it will ask the user for an input of the amount of the item they want to craft otherwise it sets the second argument as an integer and as the variable “amt”. The amount function checks whether the second input can be converted to an integer and will raise the following if the second input cannot be converted to an integer: *ValueError (“Put in a number for the second input”)*. Moving on if the second argument passes the test it’s assigned to the variable “amt”, and the amount function returns the tuple (item,amt)

## Last function (craft_req)
Lastly the **craft_req** function assigns the return value of the amount function to the variable searching and assigns the first index of searching to its local variable “item”, and the second index of searching to its variable “amt”. There is a requirement’s dictionary in the function which is used to access the crafting requirement’s of each respective item. Each item entry has its own respective crafting requirements as a dictionary with the key being the name of the ingredient and the value being the amount of each ingredient. Next there is a dictionary "converted_dict", which is used to grab the names of each required ingredient as a key and multiply their values to the "amt" value and contain them. There is another function embedded in **craft_req** called **f_conversion**, which takes in the argument of "converted_dict" and appends the ingredient and number of that ingredient within the dictionary the into a list for each ingredient as a formatted f string, wherein thereafter the list is joined together through using the *inflect.engine()* from the inflect library with the *.join()* function to be formatted appropriately as a whole sentence. Lastly I return an f string of the required variables, with its completed formatted: *** f"You need {f_conversion(converted_dict)} to make {amt} {item}" ***, and am able to print the string through the main function.

# Pytest

I also have a pytest file, which just checks for particular outcomes in specific scenarios for each main function used. Not much to say aside from I tried different arguments and used those trials to properly assess my program would catch errors when they needed to be caught, and ran properly under circumstances where it should be ran.

# Design and Project Decisions:
I had to do over around 2 times whether I wanted a class or not, and decided I wouldn’t need to make things too complicated and stuck with for the most part just functions to create this program. I told myself after a couple days of writing if I needed to add more layers I would, but I decided after those couples of days to reset and focus on the goal at hand first before worrying about the little details too much. I believe at first I was too concerned with the little details I ended up hindering my progress in the very beginning, making code a bit too complex, but after that realization I decided it’s best to create the foundation first and meet the goal in its simplest form possible before fixing the smaller issues, so when I did change things I could add them without feeling too overwhelmed.
This idea for the project actually extrapolated from my initial general want to create a search bar where if an object was typed inside it would give the user ingredients from the internet to make that object. Of course it was an idealistic goal as I didn’t even learn algorithms yet in Python. So realizing that idea was a miles away from being created with my current knowledgebase, I narrowed potential ideas down to a video game item search bar where you can search, figure out how many of that item you want to make, and return the materials needed to make that many items. And  I knew I wanted to use dictionaries in for this idea, because I felt it was perfect for searching for a set of specific items, and through those items I would also have another dictionary for the crafting ingredients of those items. As for the use of two dictionaries, the items dictionary which has the key of the item names to and value of each respective item image, and the requirements dictionary that contains the the item image as the key and the respective crafting requirements for each item image; the reason I formatted it this way was so it would be easier for people, myself included, who were to take a look at my code to follow along by separating the dictionaries. I felt if I compiled it all in the same dictionary it would be a bit confusing following along the indexing of the dictionaries if they were combined.

